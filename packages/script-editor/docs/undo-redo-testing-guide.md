# Undo/Redo 功能测试指南

## 测试环境准备

### 1. 启动服务
```bash
# 启动后端服务
cd packages/api-server
pnpm run dev

# 启动前端服务
cd packages/script-editor
pnpm run dev
```

### 2. 准备测试数据
- 创建一个测试工程
- 创建至少 2 个会谈脚本文件（如 session1.yaml, session2.yaml）
- 每个文件包含多个 Phase、Topic 和 Action

## 测试用例

### 测试用例 1：单文件内 Undo/Redo
**目标**：验证在单个文件内的撤销和重做功能

**步骤**：
1. 打开 session1.yaml
2. 修改一个 Action 的内容
3. 添加一个新的 Action
4. 删除一个 Action
5. 按 Ctrl+Z（或 Cmd+Z）三次
6. 验证：依次撤销"删除"→"添加"→"修改"
7. 按 Ctrl+Shift+Z（或 Ctrl+Y）三次
8. 验证：依次重做"修改"→"添加"→"删除"

**预期结果**：
- ✅ 每次 Undo/Redo 操作立即生效
- ✅ 焦点自动定位到被修改的节点
- ✅ 编辑区右侧显示对应节点的属性
- ✅ 顶部显示"未保存"标记
- ✅ 1秒后自动保存

---

### 测试用例 2：跨文件 Undo/Redo
**目标**：验证跨文件的撤销和重做功能

**步骤**：
1. 打开 session1.yaml，修改一个 Action（操作A）
2. 切换到 session2.yaml，修改另一个 Action（操作B）
3. 再切换回 session1.yaml，添加一个 Topic（操作C）
4. 按 Ctrl+Z（撤销操作C）
5. 验证：回到 session1.yaml，刚添加的 Topic 被移除
6. 按 Ctrl+Z（撤销操作B）
7. 验证：**自动切换到 session2.yaml**，焦点定位到被修改的 Action，内容恢复
8. 按 Ctrl+Z（撤销操作A）
9. 验证：**自动切换到 session1.yaml**，焦点定位到被修改的 Action，内容恢复
10. 按 Ctrl+Y 三次，验证重做

**预期结果**：
- ✅ 跨文件 Undo 时自动切换到正确的文件
- ✅ 左侧文件树高亮显示当前文件
- ✅ 焦点自动定位到被修改的节点
- ✅ 操作顺序按时间倒序执行

---

### 测试用例 3：焦点导航精确性
**目标**：验证焦点导航的准确性

**步骤**：
1. 在 Phase 1 > Topic 2 > Action 3 位置添加一个 ai_say Action
2. 在 Phase 2 > Topic 1 > Action 1 位置修改内容
3. 在 Phase 1 级别修改 phase_name
4. 按 Ctrl+Z 三次
5. 每次验证焦点定位

**预期结果**：
- ✅ 第一次 Undo：焦点定位到 Phase 1，右侧显示 Phase 属性面板
- ✅ 第二次 Undo：焦点定位到 Phase 2 > Topic 1 > Action 1
- ✅ 第三次 Undo：焦点定位到 Phase 1 > Topic 2 > Action 3

---

### 测试用例 4：复杂操作序列
**目标**：验证复杂操作的历史管理

**步骤**：
1. 添加 Phase（操作1）
2. 在新 Phase 中添加 Topic（操作2）
3. 在新 Topic 中添加 3 个 Action（操作3-5）
4. 修改第 2 个 Action（操作6）
5. 移动第 1 个 Action 到最后（操作7）
6. 删除第 2 个 Action（操作8）
7. 按 Ctrl+Z 5 次，然后 Ctrl+Y 3 次

**预期结果**：
- ✅ 所有操作可以正确撤销和重做
- ✅ 焦点始终跟随到正确的位置
- ✅ 数据结构保持一致
- ✅ 没有出现错误或异常

---

### 测试用例 5：历史边界测试
**目标**：验证历史栈的边界处理

**步骤**：
1. 在空历史状态下按 Ctrl+Z
2. 验证提示："已经是最早的状态了"
3. 做一些操作
4. 按 Ctrl+Y（在最新状态）
5. 验证提示："已经是最新的状态了"
6. 做超过 100 个操作（历史栈上限）
7. 验证最早的操作被移除，但不影响当前使用

**预期结果**：
- ✅ 边界情况有友好提示
- ✅ 不会出现崩溃或错误
- ✅ 历史栈自动管理大小

---

### 测试用例 6：Undo 后再编辑（分支测试）
**目标**：验证 Undo 后新操作会截断未来分支

**步骤**：
1. 做操作 A、B、C
2. 按 Ctrl+Z 两次（回到 A）
3. 做新操作 D
4. 按 Ctrl+Y
5. 验证：提示"已经是最新的状态了"（B、C 被丢弃）
6. 按 Ctrl+Z
7. 验证：回到 A 状态，不是 C

**预期结果**：
- ✅ 分支逻辑正确，Undo 后编辑会截断未来历史
- ✅ 不会出现历史混乱
- ✅ 用户始终能理解当前状态

---

### 测试用例 7：自动保存协调
**目标**：验证 Undo/Redo 与自动保存的协调

**步骤**：
1. 修改一个 Action
2. 等待 1 秒，验证自动保存
3. 按 Ctrl+Z 撤销
4. 等待 1 秒，验证自动保存撤销后的状态
5. 刷新页面
6. 验证：加载的是撤销后的状态

**预期结果**：
- ✅ Undo/Redo 后会触发自动保存
- ✅ 保存的是当前状态，不是历史栈
- ✅ 页面刷新后状态一致

---

### 测试用例 8：文件切换时的历史保持
**目标**：验证切换文件不会清空全局历史

**步骤**：
1. 在 session1.yaml 做操作 A
2. 切换到 session2.yaml
3. 按 Ctrl+Z
4. 验证：回到 session1.yaml，撤销操作 A

**预期结果**：
- ✅ 切换文件不影响历史栈
- ✅ 可以跨文件撤销操作
- ✅ 焦点自动切换文件

---

## 性能测试

### 测试用例 9：大量操作性能
**目标**：验证历史管理的性能

**步骤**：
1. 快速连续做 50 个操作（添加、修改、删除）
2. 观察界面响应速度
3. 按 Ctrl+Z 快速连续撤销 20 次
4. 观察响应速度和内存占用

**预期结果**：
- ✅ 操作响应流畅，无明显卡顿
- ✅ Undo/Redo 速度快（<100ms）
- ✅ 内存占用合理（<100MB 增长）

---

## 手动测试检查清单

- [ ] 单文件内 Undo/Redo 正常
- [ ] 跨文件 Undo/Redo 正常
- [ ] 焦点自动导航到正确位置
- [ ] 左侧树节点自动高亮
- [ ] 右侧属性面板自动更新
- [ ] 操作描述清晰（"已撤销: 修改 Action"）
- [ ] 边界情况有友好提示
- [ ] Undo 后编辑会截断未来分支
- [ ] 自动保存与 Undo/Redo 协调
- [ ] 切换文件不清空历史
- [ ] 快捷键响应灵敏（Ctrl+Z、Ctrl+Y、Ctrl+Shift+Z）
- [ ] 性能表现良好
- [ ] 没有控制台错误
- [ ] 数据一致性正确

---

## 已知限制

1. **历史栈上限**：最多保留 100 条历史记录，超过会自动删除最早的记录
2. **文件数量**：跨文件操作仅在文件未被关闭的情况下有效
3. **自动保存延迟**：Undo/Redo 后 1 秒才保存到服务器
4. **焦点导航限制**：如果节点被删除，焦点导航可能失效

---

## 调试技巧

### 查看历史栈状态
在浏览器控制台执行：
```javascript
import { globalHistoryManager } from './utils/history-manager';
console.log(globalHistoryManager.getSummary());
```

### 查看当前索引
```javascript
console.log('Current Index:', globalHistoryManager.getCurrentIndex());
console.log('Can Undo:', globalHistoryManager.canUndo());
console.log('Can Redo:', globalHistoryManager.canRedo());
```

---

## 报告问题

如果发现问题，请记录：
1. 操作步骤（详细）
2. 预期结果
3. 实际结果
4. 控制台错误信息
5. 浏览器版本和操作系统
