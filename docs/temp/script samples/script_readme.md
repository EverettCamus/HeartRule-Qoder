1. 简介
1.1 游心谷项目背景
项目简介
“游心谷”是一个专注于青少年的AI心理咨询项目。它旨在成为青少年在遇到心理困扰时的陪伴者，通过提供及时的心理支持来帮助他们度过困难时期。
问题背景
当前的心理咨询服务常常面临诸多问题，包括高昂的费用、优秀咨询师的稀缺以及咨询服务需要预先约定时间和地点，这些都限制了服务的可及性。
项目目标
通过开发“游心谷”项目，我们致力于利用电脑 AI及游戏化技术解决这些问题，使心理咨询变得更加便利和可及。该项目不仅提供模拟真人的咨询会谈服务，还计划在未来引入一些游戏化的玩法，使其更具吸引力和效果。
1.2 HEART RULE系统目的
系统定位
“HEART RULE”的脚本系统是整个“游心谷”项目的技术核心，它是实现AI模拟真人咨询会谈对话的引擎。该系统深度整合当前先进的大模型技术，旨在利用AI技术为青少年提供一个高效、贴心的心理咨询服务。
它是心理咨询技术经验的沉淀器之一，可以将心理咨询师的所有咨询技巧和经验，转成一个个逻辑规则，脚本则是这个逻辑规则的记录表达方式，最终通过HEART RULE引擎底层，控制对话过程按这些逻辑规则来进行。
功能和特点
弱编程: 通过简化编程元素，我们确保了脚本系统易于使用，即使是对编程不熟悉的人也可以轻松掌握。为了确保脚本编写的简洁性，我们将编程元素减到最少，只保留最基本的条件判断功能，从而避免了复杂的编程语句和结构，比如循环语句。
预期结果
我们期望通过该脚本系统，可以吸引具有逻辑思维和丰富经验的咨询师来编写脚本，从而将他们的经验和知识沉淀在系统中。这不仅可以为用户提供更加丰富和个性化的咨询服务，还可以不断优化和完善系统的功能和服务。

1.3 问题解决
“游心谷”项目的脚本系统专门设计来解决当前心理咨询场景中的特定问题，主要包括对话流程管理和记忆功能。
对话流程管理
该系统致力于提供一个灵活和多功能的对话流程管理工具，通过以下方式实现：
- CBT主流程: 通过坚持按照认知行为疗法（CBT）的主流程来引导对话，确保对话的流畅和有目的性。
- 动态调整: （待实现）将允许根据实时对话动态调整对话流程，包括添加或删除话题，调整话题的进度和优先级。
记忆功能
记忆功能是该系统的另一个核心功能，包括以下几个方面：
- 多级记忆:
  - 短记忆: 包括本次话题和最近的聊天记录。
  - 中记忆: 当前会谈的各作用域的变量。
  - 长记忆: 涉及整个疗程的记录和表格。
- 记忆问题解决: <--功能未开放-->
  - 信息修正: 允许用户更正先前提供的信息。
  - 更新新经历: 让用户能够更新他们的新经历和变化。
  - 敏感话题管理: 能够记录和避免涉及用户的敏感或禁忌话题。
  - 基于历史信息的对话引导: 根据用户以前的对话来引导当前的话题。
游戏化功能（待展开）
1.4 目标用户
心理咨询师
该系统的主要目标用户是心理咨询师合伙人。他们具备专业的心理咨询知识和丰富的实践经验，致力于将他们的经验和技术沉淀到AI心理咨询项目中，使之更具效率和智能化。
用户需求
心理咨询师合伙人希望能有一个“分身”来进行心理咨询，确保整个咨询过程能够符合他们的咨询经验和技术，同时也可以不断地进行迭代和更新。他们需要在必要时介入，调整诊断分析、咨询策略、咨询计划以及用户作业安排等。
用户价值
通过使用该系统，心理咨询师可以在保持服务质量的前提下提升服务效率，从而获得更多的收入。此外，它也为他们提供了一个平台，可以让他们的经验被更多的人复用和学习，从而实现知识的传承和积累。
用户交互
用户将通过VSCode（用于编写YAML脚本）和一个Web版的对话试调页面（用于调试）来与系统互动。这为用户提供了一个直观和高效的工作环境，可以方便地编写、测试和迭代脚本，确保脚本的高质量和咨询的有效性。
2. 示例脚本
2.1 脚本示例
在这一部分，我们将创建一个简单的示例脚本来展示“游心谷”项目的基本功能。该脚本将包括一系列基本的动作和对话来引导用户进入一个心理咨询的会谈。
让我们从创建一个“hello.yaml”脚本开始，这个脚本将通过一个简单的问候来开始会谈，并提供一些基本的用户选项来引导对话的方向。脚本内容如下：
sessions:
- session: 首次会谈
  stages:
  - stage: 进入心谷大门
    steps:
    - goal: 询问名称
      actions:
        - say: "欢迎来到游心谷，我是心谷的守望精灵。"
        - user_option: 用户选择
          choices:
          - A: "心谷是什么地方?"
          - B: "我要进入心谷"
        - say: "心谷是你的内心世界，你可以看到你的各种念头、想法、情绪，你要进去看看吗？"
          condition: "{用户选择}=='A'"
        - user_say: 是的，我想进去
          condition: "{用户选择}=='A'"
        - say: 进去前，需要先收集你一些信息
        - user_say: 没问题，你问吧
        - ai_ask: 向心旅者询问名字。
              询问策略：
              1、先简单问一句名称，例如：我该怎么称呼你
              2、当从心旅者的回复发现他有顾虑时，再追问提示他可以用网名，小名都可以，不一定用真名。
          output:
          - get: 心旅者名
            define: 心旅者给出的名称
        - ai_say: 根据心旅者给的名称{心旅者名}，进行一句简短的赞美

---
roles:
- role: 守望精灵
  define: 心谷向导（心理咨询师）的助手，心旅者的心情陪伴者
  type: AI
  name: 喵喵

- role: 心谷向导
  define: 心谷向导，用于模拟心谷向导
  type: AI
  name: 萌加加
  
- role: 心旅者
  define: 进入到心谷，被现实困住的人
  type: HUMAN
  name: "迷路者"
2.2 调试脚本
2.2.1 上传脚本
2.2.2 运行脚本
2.3 同步脚本
修改完脚本，可以通过同步，让协作者也可以下载到同样脚本。同时可以实现版本的管理，未来可以获得任意一次同步过的脚本。
3. 脚本功能介绍
3.1 概念
3.1.1 变量（VAR)
什么是变量
在脚本系统中就像是一个小盒子，用来保存某个信息，方便我们在之后的对话中取出来用。
1. 案例一：假设心旅者告诉了我们他的名字是"小明"。我们可以把"小明"保存到一个名为"心旅者名字"的盒子（变量）里。之后，如果想提到他的名字，直接从这个盒子里取就行了，例如：“{心旅者名字}，你今天感觉怎么样？”。
2. 案例二：在一次心理咨询中，心旅者说他最近很喜欢听“流行音乐”。我们可以把“流行音乐”保存到一个叫“喜欢的音乐类型”的盒子（变量）里。以后可能会说：“听说你喜欢{喜欢的音乐类型}，它给你带来了怎样的感受呢？”
3. 案例三：如果心旅者表示最近的心情是“焦虑的”，我们就把“焦虑的”保存到“当前心情”这个盒子（变量）里。之后可以根据这个心情来提供相应的建议，比如：“针对你{当前心情}的情感，我建议……”。
如何定义变量
1、全局定义：
在global.yaml文件中，作用范围为全局，即可以在跨不同的会谈脚本中都能用到。
global:
- var: [变量名]
  define: [提取对应信息的提示词]
  value: [预设值]
  auto: [true|false]
- - var: [变量名]：定义变量名，可以用中文也可以用英文，比如“自动思维”
-   define: [提取对应信息的提示词]：对这个信息的定义或说明，比如“符合情境与情绪之间的认知内容，情境通过该内容引发了情绪和行为反应”
-   value: [预设值]：（非必要项，如果没有该变量值初始为null）
-   update: [auto|get]：是否自动更新变量。见“自动更新变量”。
示例：
global:
- var: 心旅者名
  define: 心旅者允许心谷向导和助理在对话中对他本人的称呼
  value: "心旅者"
- var: 精灵名
  define: 助理希望心旅者对自己的称呼
  value: "小爱"
2、session\stage\goal的局部变量 
session的局部变量
- session: 评估性会谈
  declare: 
  - var: 执行的话题数
    define: 运行的goal的数量
    value: 0
stage的局部变量：
- stage: 中间环节
  declare: 
  - var: 用户禁忌
    define: 从对话中判断用户禁忌的事情
    value: 无
    auto: true
goal的局部变量
- goal: 来访者主诉
  declare: 
  - var: 用户情绪
    define: 从对话中判断用户当前的情绪
    value: 正常
  actions:
  - ask: 你喜欢什么水果
    output:
    - get: 喜欢的水果
      define: 用户讲述自己喜欢的水果
- 在action的output中，get对应的变量如果没定义过，也会自动定义一个goal级别的。详见get工作原理
如何使用变量
在变量名两边加{}
- say: 嵌入在一句中的{变量名}
可以放在say, ask, ai_ask,think等语句或提示词中，例如：
- say: 用户喜欢｛喜欢的水果｝

- think: 请根据用户喜欢的食材列表和不喜欢的食材列表，判断用户是否喜欢吃青椒牛肉。
    喜欢的食材列表:
    {喜欢的食材}
    
    不喜欢的食材列表：
    {不喜欢的食材}
  output:
  - get: 是否喜欢青叔牛肉
    define: 如果判断为喜欢，设定为'true', 否则设为'false'
可以放在条件语句中
- say: 我推荐你吃青椒牛肉
  condition: "{是否喜欢青叔牛肉}=='true'"
变量作用范围与覆盖规则
在脚本中，变量的作用范围根据定义的位置可以分为全局变量和局部变量。
1. 全局变量：在 global.yaml 文件中定义，整个脚本中都可以访问。
2. session变量：仅在特定的session内有效。
3. stage变量：仅在特定的stage内有效。
4. goal变量：仅在特定的goal内有效。
覆盖规则：
当存在同名变量时，变量的覆盖顺序如下：
goal > stage > session > global
这意味着，如果在goal中定义了一个变量，它将优先于在stage、session或global中定义的同名变量。类似地，stage中的变量会覆盖session和global中的同名变量，而session中的变量会覆盖global中的同名变量。
示例：
如果在global中定义了一个变量var: 用户情绪 value: 正常，而在某个goal中也定义了一个同名变量var: 用户情绪 value: 伤心，那么在这个goal中，使用{用户情绪}变量时，其值将为伤心。
3.1.2 大语言模型（LLM）
LLM是一个计算机程序，它通过大量的文本数据训练，能够生成人类般的文本，并对各种问题进行回答。简单说，LLM就像一个读过无数书籍、文章的"超级学霸"，能够帮你回答问题或生成有趣的内容。
- GPT-3（OpenAI）： Generative Pre-trained Transformer 3（GPT-3）是最著名的LLM之一，拥有1750亿个参数。该模型在文本生成、翻译和其他任务中表现出显著的性能，在全球范围内引起了热烈的反响，目前OpenAI已经迭代到了GPT-4版本
- BERT（谷歌）：Bidirectional Encoder Representations from Transformers（BERT）是另一个流行的LLM，对NLP研究产生了重大影响。该模型使用双向方法从一个词的左右两边捕捉上下文，使得各种任务的性能提高，如情感分析和命名实体识别。
- T5（谷歌）： 文本到文本转换器（T5）是一个LLM，该模型将所有的NLP任务限定为文本到文本问题，简化了模型适应不同任务的过程。T5在总结、翻译和问题回答等任务中表现出强大的性能。
- ERNIE 3.0 文心大模型（百度）：百度推出的大语言模型ERNIE 3.0首次在百亿级和千亿级预训练模型中引入大规模知识图谱，提出了海量无监督文本与大规模知识图谱的平行预训练方法。
3.1.3 提示词 （PROMPT）
发给大语言模型LLM的请求，以常规语言描述的方式。在脚本系统中就像是给咨询师递了一张小纸条，告诉他接下来要讲的话题或方向，然后咨询师根据这个小纸条来引导对话。
1. 案例一如果我们想让咨询师了解心旅者的工作状况，就递给咨询师一张写着“请询问心旅者最近工作情况，询问时不要问太细”的小纸条（提示词）。咨询师看了可能会问：“你的工作最近忙吗？有什么特别的变化或压力吗？”。
2. 案例二：当我们希望咨询师探讨心旅者的家庭关系，我们就给咨询师一张标有“根据刚才了解到的心旅者家庭成员，逐一询问他跟每个人的关系”的小纸条（提示词）。咨询师接到后可能会提问：“你和家人的关系如何？最近有没有什么事情影响了你们的关系？”。
3.2 脚本文件介绍
- first-day.yaml (会谈脚本样板)
- forms.yaml（咨询笔记，表单定义）
- global.yaml（全局变量，脚本过程逻辑变量）
- roles.yaml（角色配置）
- skills.yaml（技能库）
- yaml_schema.json（yaml文件格式验证）
3.2.1 会谈脚本文件
sessions.yaml，这类文件主要是存放心理咨询对话过程的剧本。例如上面first-day.yaml，文件名可以根据业务需要起。建议一个文件只放一次咨询的脚本，例如：评估性会谈脚本，咨询性会谈脚本，巩固性会谈脚本。
3.2.2 表单定义文件
forms.yaml，这里根据咨询技术要求，定义一些用户信息的表单。例如咨询笔记等。咨询脚本把一些关键的信息存放到表单中，咨询师可以在“咨询师系统”中查看的，了解到具体用户的情况。
<--功能未开放-->
3.2.3 全局变量定义文件
该文件存在对话过程中，脚本逻辑需要用到的全局变量。例如在global.yaml中定义“用户当前心情”变量。在会谈脚本a.yaml中可以从对话过程思考分析当前心旅者心情，在b.yaml文件如果执行，可以利用这个心情的分析结果，进行一次回应。
global.yaml
global:
- var: 用户当前心情
  define: 心旅者当前回复中透露出的心情
a.yaml
- think: 从心旅者的回复中，判断出当下的心情
  output:
  - get: 用户当前心情
b.yaml
- ai_say: 用户当前处理{用户当前心情}的心情，请根据心情给出一句回应的话
“global”这个词代表了下面的定义都是全局变量，“- var”代表“变量名”，“define”代表了这个变量值的具体定义或如何提取的提示词。
3.2.4 角色定义文件
roles.yaml，设定了对话过程中会涉及到的角色，比如守望精灵（咨询师小助理），向导（咨询师），心旅者（来访者），儿时心旅者（来访者小时候）。
roles: 
- role: 心谷向导
  type: AI
  sound_mode: HEART_GUIDE
  define: 心谷世界的向导，是游戏化的心理咨询师
  name: 萌加加
  pic: ./skin3/images/heart_guide.png
  tone: 温和、同理心、坚定但不强制、积极肯定、开放倾听、尊重无评判、清晰有条理、保持专业边界
  
- role: 心旅者
  type: HUMAN
  define: 心谷世界的旅行者，是游戏化的来访者
  sound_mode: HEART_TRAVELER
  name: "迷路者"
  pic: /images/roles/心旅者.png
type: 两种type，AI和HUMAN。主要代表了这个角色是由谁来操控，是人还是电脑
tone: 语言风格，主要是针对type=AI的，由电脑生成的话才需要指定风格。风格定义只要挑重点，不要太多，太多信息不一定会被遵守。这个语言风格是这个角色的默认风格，具体情景语气可以在ai_say、ai_ask中去定义，例如下面示例。
- scene: 咨询室内
  ai: 心谷向导
- ai_say: 100个字介绍一个心谷
  tone: 幽默、夸张
3.2.5 技能库文件
skills.yaml，在会谈过程中，会用到很多对话技巧，例如控辩方技术，识别情绪技术等。不同的会谈脚本存在使用同一个对话技巧，为了更好的复用这些脚本代码，设定了“技能库文件”。这里定义的技能goal，可以在会谈脚本中通过call来调用，也可以在规则脚本rules.yaml中，通过call来调用。
skills:
- goal: 深度了解关系情况
  declare:
    - var: 角色
      define: 相对于心旅者的关系角色
    - var: 称呼
      define: 心旅者对他的称呼
    - var: 关系情况
      define: 心旅者该角色的关系情况
  actions:
  - ai_ask: 询问与{角色}{称呼}日常相处的关系情况，只要心旅者讲述了，就不再询问
    output:
    - get: 关系情况
      define: 心旅者该角色的关系情况
      
- goal: 识别情绪
  declare:
- goal: 这里定义了很多的技能脚本，每个技能脚本都是实现一个独立的目标的会谈行为，因此也命名为goal。
- declare: 定义这个技能脚本会用到的一些变量，这些变量允许从外部传入。变量的作用域为当前goal
- actions: 一系列的行为脚本，say, user_say, user_option, ai_ask, think等
注意：
- goal的名称不要重复，是唯一识别一个技能的
3.2.6 YAML格式验证文件
yaml_schema.json，这份文件由开发人员维护，写脚本的咨询师不要修改。这份主要是对其它yaml文件进行格式的约束。一旦yaml中写错，在VSCode环境下就会出现“红波浪线”。具体如何在VSCODE中如何配置这个验证文件，见配置schema文件。
3.3 会谈脚本结构
sessions:
- session: 首次会谈
  stages:
  - stage: 进入心谷大门
    steps:
    - goal: 询问名称
      actions:
        - say: "欢迎来到游心谷，我是心谷的守望精灵。"
3.3.1 session
会谈，一个会谈指一次咨询。不同的因素影响了一次会谈的安排会有不同，包括不限于以下因素：
- 从咨询进程角度，有评估性会谈、咨询性会谈、巩固性会谈；
- 从咨询阶段，有自动思维阶段、中间信念阶段、核心信念阶段；
- 从心理问题分类，有焦虑障碍、抑郁障碍、双向情感、成瘾障碍等；系统会预设好不同心理问题的模板，以便新入的咨询师复制使用。
- 从不同咨询流派，有CBT、家庭关系、后现代等，甚至可以把咨询技术融合创新。
- 从同一流派不同咨询师，每个细节都不同；每个咨询师的会谈模板从初始脚本模板复制过来后，可以独立维护修改。不同咨询师之间也可以分享模板。
- 从同一咨询师不同情景，不同会谈策略。每个咨询师从初始脚本模板复制过来，可以进行扩展修改。
会谈脚本可以有很多份
3.3.2 stage
会谈阶段，一次会谈可以分成几个大阶段。比如在CBT的评估性会谈可以分成开始环节，中间环节，结束环节。
设立阶段的作用：1、匹配一次会谈情景，方便时间管理；2、作为话题坐标，一些新增的话题可以通过策略插入到本stage结束时去执行。
每个Stage下有一个steps列表，由各种Step组成。最主要就是一个个goal。
3.3.3 goal
话题，每个话题都有一个最小对话目标，比如了解个人基本信息，了解过往咨询经历。对应到《认知行为疗法：会谈技能与咨询技巧》一书中，每个“”信息维度的收集。
- 每个goal有一个名称，该名称应该是整个stage中唯一的，不能重复。
- actions代表一个列表，下面有一组列表元素，过程是顺序执行。
- 每个action，如user_say, say等都需要在前面加一个“- ”，YAML文件中，代表列表元素。
    - goal: 初遇精灵
      actions:
      - user_say: 好大的雾呀，怎么什么都看不清？
      - say: 你终于醒了...你的旅程即将要开始
      - user_say: 旅程？
      - say: 就是心谷的探险之旅
      - user_say: 心谷？
      - say: 心谷是一个神秘的世界，是你内心世界的投影
任何聊天过程可以理解为一个一个话题的串联在一起。当然哪个话题要优先，哪个话题因为时间限制需要放弃，哪个话题要插入，是整个对话管理的关键。
写脚本时话题颗粒度的把握需要认真老师，是要把10个action放一个话题，还是拆成两个话题。可以从脚本的复用角度和话题独立性角度去考虑。
- 复用角度：可以说goal是最小的复用单位，同一话题脚本可以代入不同的初始变量，类似程序中的函数。
- 独立性角度：话题管理的对象，做咨询计划，增减话题，调整话题顺序等，都是以goal为对象。
3.3.4 action
对话过程的不同交互方式，都是一个action。例如AI发出一句预置的话，对应了say；用户做选择对应了user_option；AI追问，对应了ai_ask；请用户填表，对应了fill等。action包括了咨询技术用到的一些交互方式，游戏化也会需要扩展更多的action功能。
3.4 Action功能
3.4.1 say
功能：代表AI角色发送预置的话给用户。
格式:
- say: [AI角色讲述的话]
  condition: [执行条件]
- [AI角色讲述的话]：代表AI角色，具体讲话的文字信息，里面可以带变量
- 注意空格，冒号要用半角“:”
- condition: [执行条件]：（非必要项）条件表达式，返回TRUE时，才会执行本action。具体参见condition介绍。
示例：
- say: 你好，欢迎来到心谷，我是这里的守望精灵，你可以叫我“{守望精灵名}”
output:
守望精灵: 你好，欢迎来到心谷，我是这里的守望精灵，你可以叫我“小爱”
用途：
- 故事剧情：游戏化的故事背景，有一些固定的介绍可以用到。例如：“心兽是你内心最根深的思想，最有力量的情绪。”
- 开场白：每次会谈开始时，咨询师可能会有一个固定的开场白来建立与心旅者的联系。例如：“你好，感谢你再次来到这里，希望我们今天能一起找到答案。”
- 会谈结尾：在会话结束时，咨询师可能会有一句固定的结束话语。例如：“今天的会话就到这里，希望你能有所收获。期待我们下次的相聚。”
- 转移注意力：在某些敏感话题或情况下，为了避免心旅者的过度情绪，咨询师可能会使用预置的话语来转移心旅者的注意力。例如：“让我们先深呼吸，然后继续我们的对话。”
- 定时的鼓励：在心旅者分享某些情感或经验时，咨询师可能会有预置的鼓励性话语。例如：“你做得很好，勇敢地分享自己的感受。”
- 介绍活动：当引入某个活动或练习时，咨询师可能会有预置的说明。例如：“现在，我想请你尝试一个小练习，它可能会帮助你更好地理解自己的感受。”
- 固定的技术指导：在引导心旅者进行某些技巧或活动时，咨询师可能会用到预置的指导性话语。例如：“现在，请你尝试闭上眼睛，深深地呼吸，并集中注意力在你的呼吸上。”
- 安全提醒：在某些情况下，为确保心旅者的安全，咨询师可能需要用到预置的提醒话语。例如：“如果你在这个过程中感到不适，请随时告诉我，我们可以暂停。”
3.4.2 user_say
功能：代表HUMAN角色，发一句话。
格式:
- user_say: [HUMAN讲述的话]
  condition: [执行条件]
- [HUMAN讲述的话]：代表了用户角色，讲述的文字
- 注意空格，冒号要用半角“:”
- condition: [执行条件]：（非必要项）条件表达式，返回TRUE时，才会执行本action。具体参见condition介绍。
示例：
- say: 你好，欢迎来到心谷，我是这里的守望精灵，你可以叫我“{守望精灵名}”
- user_say: {守望精灵名}，你好，我这是在哪里？
Output:
守望精灵: 你好，欢迎来到心谷，我是这里的守望精灵，你可以叫我“小爱”
心旅者: 小爱，你好，我这是在哪里？ 
- 输出后，用户需要点“心旅者: 小爱，你好，我这是在哪里？”，才会下一步
用途：
- 增强长介绍时用户互动感：有时候系统会讲一系列的话，中间可以通过user_say，代替用户回复“好的”“然后呢”“我明白，帮我也算是帮了你”了等台词，用户需要点击操作才继续往下。增加了用户的参与互动感。
- 方便用户理解信息：从用户角度对AI讲出的话，换一种用户角度的表达，可以方便用户理解。
- 展示故事背景剧情：配置say，进行背景剧情的介绍。
3.4.3 user_option
功能：用户做单选
格式:
- user_option: [result]
  condition: [执行条件]
  choices:
  - [key]: [value]
  - [key]: [value]
  ...
- - user_option: [result]：result是用户选择[key]的输出变量，下例中为“外出聚会频率”，可以根据需要定义一些表意的文字
- choices：代表下面可以有候选项，选项格式,注意冒号后有空格：- [key]: [value]
- [key]：可以自己定义，一般如“A”“B”“C”，或“1”“2”“3”，当然也可以是任意字符串，比如“伤心”“愤怒”等。
- [value]：可以选项的内容文字
- 注意空格，注意缩进，冒号要用半角“:”
- condition: [执行条件]：（非必要项）条件表达式，返回TRUE时，才会执行本action。具体参见condition介绍。
示例：
- say: 那么请告诉我你最近外出的频率
- user_option: 外出聚会频率
  choices:
  - A: 几乎每天
  - B: 至少每周一次
  - C: 至少一个月一次
Output:
守望精灵:  那么请告诉我你最近外出的频率
心旅者:- A: 几乎每天
心旅者:- B: 至少每周一次
心旅者:- B: 至少每周一次
心旅者:- C: 至少一个月一次
- 输出后，用户需要点其中一个选项，如“心旅者:- A: 几乎每天”，“心旅者:- B: 至少每周一次”，“心旅者:- C: 至少一个月一次”任意一下，对话才会继续
用途：
- 增强长介绍时用户互动感：有时候系统会讲一系列的话，中间可以通过user_say，代替用户回复“好的”“然后呢”“我明白，帮我也算是帮了你”了等台词，用户需要点击操作才继续往下。增加了用户的参与互动感。
- 方便用户理解信息：从用户角度对AI讲出的话，换一种用户角度的表达，可以方便用户理解。
- 展示故事背景剧情：配置say，进行背景剧情的介绍。
3.4.4 ai_say
功能：代表AI角色，发送由AI生成的话给用户。
格式:
- ai_say: [引导AI生成话语的提示词]
  tone: [语气提示词]
  condition: [执行条件]
- [引导AI生成话语的提示词]：引导LLM生成具体说话内容的提示词。
- tone: [语气提示词]：一些语气和语言风格的要求。（非必填，默认采用当前AI角色在roles.yaml中定义的tone）
- 需要多行，可以加“|”，如：- ai_say: |
- 注意空格，注意缩进，冒号要用半角“:”
- condition: [执行条件]：（非必要项）条件表达式，返回TRUE时，才会执行本action。具体参见condition介绍。
示例：
- ai_say: 根据名字“{心旅者名}”的特点进行赞美，并写一个藏头对联，要符合这个名字特点的
  tone: 文言，风雅，简短
output:
守望精灵:永如泉水，静而有波，润万物而不争。
守望精灵:对之以联儿，
守望精灵:李树春来早，永存阙中。
守望精灵:泉涌冬不竭，松鸣海角。
- 生成内容，会根据给的变量信息和上下文聊天不同而不同，同样变量信息，生成也不同。
用途：
- 情感识别与回应：
  在咨询过程中，心旅者可能会描述自己近期的情感或体验。ai_say可以用来生成有同理心的回应。
- ai_say: 根据心旅者描述的情感"{心旅者情感}"给出一个同理心的回应
  tone: 温暖, 同理心
output：
守望精灵:“听起来你最近经历了不少，真的很不容易。”
- 生成情绪管理建议：
  当心旅者遭遇情绪困扰时，咨询师可以建议他们尝试一些情绪管理的技巧。ai_say能生成适当的建议。
- ai_say: 提供一个适用于"{心旅者情绪}"的情绪调节方法
  tone: 专业, 帮助性
output:
守望精灵:“面对愤怒时，你可以试试深呼吸法，这有助于平复情绪。”
- 给出练习任务：
作为会话的一部分，ai_say可以为心旅者提供练习或家庭作业。
- ai_say: 给心旅者提供一个与"{当前话题}"相关的家庭作业或练习
  tone: 指导性, 鼓励性
output：
守望精灵：“关于我们刚才讨论的压力管理，我建议你每天抽出10分钟进行深度放松练习，并观察一周后的效果。”
3.4.5 ai_ask
功能：代表AI角色，按任务提示，持续引导用户详述。会连续追问多个问题，中间用户如果有问题也会通过AI自动回答。结束后，从聊天过程提取信息。
格式:
- ai_ask: [让AI生成连续引导用户讲述的提示词]
  tone: [语气提示词]
  exit: [退出连续追问的条件]
  condition: [执行条件]
  output:
  - get: [变量名1]
    define: [提取信息的提示词1]
  - get: [变量名2]
    define: [提取信息的提示词1]
    ...
  - set: [变量名3]
    value: [直接设置的值]
- [让AI生成连续引导用户讲述的提示词]：引导LLM生成具体说话内容的提示词。
- tone: [语气提示词]：一些语气和语言风格的要求。（非必填，默认采用当前AI角色在roles.yaml中定义的tone）
- exit: [退出连续追求的条件]：这段是让AI结束本次追求信息收集的结束提示词，这里可以描述完成任务的具体判断标准。（非必填，默认为“完成引导任务后”）
- condition: [执行条件]：（非必要项）条件表达式，返回TRUE时，才会执行本action。具体参见condition介绍。
- output: 要从当前对话收集的信息，具体参见output介绍
- 注意空格，注意缩进，冒号要用半角“:”
- 需要多行，可以加“|”，如：- ai_ask: |
示例：
- ai_ask: |
    在下面已经知的人际关系情况下，进一步详细了解心旅者在外部世界的人际关系情况
    
    注意事项：
      1、根据心旅者基本情况，逐一判断下面的关系类型是否合适问，如果合适进行详细了解。
        可选了解的关系类型：
        A)原生家庭关系(父母关系\同胞关系\祖父母关系\其他家庭成员)
        B)婚姻家庭关系(恋爱关系\夫妻关系\亲子关系\配偶父母关系\其他家庭成员)
        C)学校关系(师生关系\干部同学关系\男女同学关系)
        D)职场关系(上司关系\同事关系\客户关系\下属关系)
        E)社交关系(朋友关系)
      2、分成几轮进行询问，每次问一个话题  
     
     人际关系情况：
     {人际关系情况}
  exit: 当心旅者讲述完关于人际关系的问题
  output:
  - get: 人际关系问题
    define: 提取讲述到的心旅者当下或曾经有过的人际关系问题  
output（对话过程）:
"向导":"很好，让我们从你和你的家人的关系开始吧。你可以告诉我一下你和你的父母的关系如何吗？有没有什么特别重要的事情或者矛盾需要我了解呢？"
他们对我是很好，但我母亲总是把我的事给别人讲。我都跟她讲很我遍了。我爸小时候打过我几次，打的时候很凶
"向导":"听起来你和你的父母有一些不愉快的经历。对于你母亲在没有得到你同意的情况下讲述你的事情，以及你父亲过去对你的行为，你有何感受呢？这些事情对你产生了哪些影响？"
我很失望，觉得人与人之间没有什么可以信任的，都是虚假的。
"向导":"我理解你的失望和疑惑，人际关系中的信任是非常重要的。那你有没有想过，这种对人际关系的不信任感会不会影响到你和其他人的关系，比如你的朋友、同学或者其他亲人呢？"
同学基本都没联系了，亲人现在也没联系。
"向导":"看起来你现在和你的同学或者其他亲人没有太多的联系。那么，你还有没有朋友，你们之间的关系是怎样的呢？有没有什么特别的事情或者矛盾需要我了解的？"
跟他们都没什么矛盾，只是我现在这个状态不太想见他们
"向导":"我明白你现在可能需要一些独处的时间，这是完全正常的。感谢你分享了你的感受和经历，这对我们接下来的探索会很有帮助。"
output（取出信息）:
"人际关系问题": {
    "父母关系": {
        "母亲": "经常在没有得到许可的情况下分享他的事情",
        "父亲": "小时候曾经打过他，态度凶狠"
    },
    "朋友关系": "没有明显的矛盾，但由于当前的心理状态，不太想见他们",
    "同学和其他亲人关系": "基本上没有联系",
    "对人际关系的看法": "感到失望，认为人与人之间没有什么可以信任的，都是虚假的"
}
- 生成内容，会根据给的变量信息和上下文聊天不同而不同，同样变量信息，生成也不同。
用途：
- 连续追问以便收集信息：如示例中所描述，可以通过连续追问的方式，深入了解心旅者的某一方面情况，如人际关系、工作状况、心理困扰等。
- 询问用户有什么疑问并回答：当心旅者提出疑问时，ai_ask可以自动回答，并根据心旅者的回应继续深入询问。
- 导引冥想或放松练习：ai_ask可以引导心旅者进行冥想或其他放松练习，期间询问心旅者的身体感受、心境变化等，来调整引导过程。
- 角色扮演：为了帮助心旅者更好地处理某些人际关系问题，可以邀请他们进行角色扮演。在这个过程中，ai_ask可以帮助设定场景、反馈心旅者的表达等。例如，控辩方技术。
- 帮助心旅者自我探索：不仅是收集信息，而是引导心旅者自我反思，帮助他们更加深入地认识自己。
- 设定任务或挑战：为了帮助心旅者改变某些不良习惯或培养某些技能，可以设置一些小任务或挑战，并询问他们的计划与策略。
- 验证与核实信息：当AI收集到某些信息后，可以使用ai_ask来验证这些信息的准确性。
3.4.6 think
功能：在聊天信息与之前读取到变量的信息上，进行特定的分析，提取分析结果
- think: [分析思考的提示词]
  condition: [执行条件]
  output:
  - get: [变量名1]
    define: [提取信息的提示词1]
  - get: [变量名2]
    define: [提取信息的提示词1]
    ...
  - set: [变量名3]
    value: [直接设置的值]
- - think: [分析思考的提示词]：进行思考分析的提示词，里面可以带上之前收集的一些变量信息。
- condition: [执行条件]：（非必要项）条件表达式，返回TRUE时，才会执行本action。具体参见condition介绍。
- output: 要从当前对话收集的信息，具体参见output介绍
- 注意空格，注意缩进，冒号要用半角“:”
- 需要多行，可以加“|”，如：- think: |
示例：
- think: 总结本周工作经历
  condition: (这里可以设置某些条件，例如对话中出现"本周"和"工作"等关键词)
  output:
  - get: WorkProjects
    define: 参与了哪些项目的会议
  - get: OvertimeHours
    define: 每天都加班到多晚
  - get: Achievements
    define: 收获和学到了什么
  - get: Compliments
    define: 得到了哪些人的表扬
用途：
- 从指定的聊天对话中去总结信息：
  - 情景描述：在进行较长时间的咨询或交谈后，使用think进行对话内容的回顾和总结。
  - 示例：对话涉及用户描述了自己的一周工作经历，AI使用think总结用户的主要工作压力点和高兴的时刻。
- 将之前收集的信息进一步分析出结论：
  - 情景描述：在了解用户的一系列信息后，如饮食、运动、心情日记等，使用think进行分析，找出可能的模式或趋势。
  - 示例：用户描述了自己一个月的饮食习惯，AI使用think分析其饮食是否均衡，是否有助于健康。
- 思考出一个方案（计划，作业安排）：
  - 情景描述：在获得用户的需求或目标后，使用think来为用户规划一个方案或计划。
  - 示例：用户希望提高自己的编程技能，AI使用think来为用户制定一个为期三个月的学习计划。
- 进行情绪或情感的分析：
  - 情景描述：在用户分享了自己的经历或故事后，使用think分析用户可能的情感或情绪状态。
  - 示例：用户描述了和朋友的一次争吵，AI使用think分析争吵的原因和用户当前的情感状态。
- 进行预测或建议：
  - 情景描述：基于用户提供的历史数据或经验，使用think预测未来的趋势或给出建议。
  - 示例：用户分享了自己的投资记录，AI使用think预测接下来可能的投资趋势并给出投资建议。
- 对比和评估：
  - 情景描述：当用户提供了多个选项或方案时，使用think进行对比评估，帮助用户做出决策。
  - 示例：用户考虑买A车还是B车，分享了两车的参数和自己的需求，AI使用think帮助用户评估哪款车更符合其需求。
3.4.7 condition
功能：进行条件判断，如果条件判断为TRUE，则执行相应的Action。匹配各类action使用。
   condition: ［条件表达式］
条件表达式：在编程中，条件表达式用于根据特定条件决定代码的执行路径。这些条件通常返回一个布尔值：真（true）或假（false）。这里采用javascript语法。
JavaScript 条件表达式的基础要素：
1、比较操作符
这些操作符用于比较两个值。以下是最常用的比较操作符：
- ==：等于（注意，它不检查类型，例如，"5" == 5 会返回 true）
- ===：严格等于（同时检查值和类型，例如，"5" === 5 会返回 false）
- !=：不等于
- !==：严格不等于
- >：大于
- <：小于
- >=：大于或等于
- <=：小于或等于
2、逻辑操作符
用于将多个条件结合起来：
- &&：逻辑与。当且仅当所有条件都为 true 时，整个表达式才为 true。
- ||：逻辑或。只要任一条件为 true，整个表达式就为 true。
- !：逻辑非。用于反转布尔值。
示例：
- user_option: 用户选择
  choices:
  - A: 好的我明白了
  - B: 等等，我还有问题
  
- say: 在我们进入下一环节前，您需要先登录
  condition: "{用户选择}=='A'" && !{是否已登录}"
- {用户选择}==='A'：检查用户是否选择了 "A"。
- !{是否已登录}：确保用户尚未登录。如果 {是否已登录} 返回 true，那么 !{是否已登录} 会返回 false，反之亦然。
提醒事项
- 字符串必须用单引号（'）或双引号（"）包裹起来。
- 注意区分赋值操作符（=） 和比较操作符（== 或 ===）。
- 对于小白来说，推荐始终使用 === 和 !== 进行比较，因为它们同时检查值和类型，可以避免某些意外情况。
3.4.8 output
功能：主要是提取用户回复的信息。output在ask、ai_ask、think中都可以用到，这种提取一般也是通过给LLM提示词来完成对信息的识别摘要。
- ai_ask: [询问提示词]
  output:
  - get: [变量名]
    define: [如何提取信息的提示词]
  - set: [变量名]
    value: [要设置的值]
-   - get: [变量名]: 提取信息到变量中。变量可以是global、stage、goal定义过的变量，也可以没定义过。没定义过，自动创建一个在本goal生效的变量
-     define: [如何提取信息的提示词]：主要是介绍如何从聊天记录或给的信息中，进一步去分析提取关键信息
-   - set: [变量名]：为某个变量设置值
-     value: [要设置的值]：要设置的值，可以是一个给点的字符串，也可以是另一个变量的引用，如{喜欢颜色}
- 在ai_ask时，只有在追问结束，即exit=='TRUE'之后，才会去提取信息。
- ask、ai_ask是从本次产生的聊天记录中去提取的
- think则默认从本来goal的聊天记录中去提取，也可以从think的提示词中去分析，提示词可以把之前的变量代入。
示例：
actions:
- ask: "你喜欢什么颜色?"
  output:
  - get: 喜欢的颜色
    define: 用户回复的喜欢的颜色
当在output中使用get进行数据提取时，该行为默认是将用户的输入信息赋值给一个变量。如果在global、session、stage和goal中都没有预先定义这个变量，则系统会自动声明一个goal级别的局部变量。
get操作的工作原理：
1. 在用户回复之后，系统会使用define中的提示词进行信息提取。
2. 提取到的信息会被赋值给get后面定义的变量。
3. 系统首先会检查该变量是否已在global、session、stage或goal中被定义。
4. 如果没有找到预定义的变量，系统会自动在当前goal中声明一个新的局部变量，并将用户回复的信息赋值给这个新变量。

在上述示例中，如果用户回复“蓝色”，并且在global、session、stage和goal中都没有预先定义喜欢的颜色这一变量，那么系统会自动在当前goal中创建一个新变量喜欢的颜色，并赋值为“蓝色”。
总结：这种自动声明机制简化了编程过程，减少了脚本中的冗余声明，并允许更加灵活地从用户对话中提取和使用数据。但同时，为了保持脚本的清晰和可维护性，如果已知将要提取某些特定的数据，建议在适当的地方预先定义变量。
set
可以直接将某个变量设置成某个值。可以做一些控制变量的初始化
- ask: ...
  output:
  - set: 是否要询问子女情况
    value: "false"   
3.4.9 call
功能：调用技能库skills.yaml中的技能goal，会创建出一个新的话题，允许立即执行或插入到会谈的某个阶段再进行
格式:
- call: [技能名称]
  timing: [新话题插入方式]
  timing_to: [新话题插入位置]
  fromlist: [列表名]
  input:
  - set: [调用变量]
    value: "{[技能变量]}"
  output:
  - set: [调用变量]
    value: "{[技能变量]}"
  condition: [执行条件]
- - call: [技能名称]：一个技能需要有一个全局唯一的名称，call只需要指定这个技能名就可以调用。全局范围指一套脚本模板，不同套的脚本模板相互独立。
- timing: [新话题插入方式]：定义了新话题如何插入到话题列表中。可以选择以下几种方式["NOW", "BEFORE_GOAL", "AFTER_GOAL", "AFTER_STAGE"]
  - NOW: 立即执行新话题，并结束当前话题。例如：识别用户对当前的对话产生反感，需要立即停止本对话，且调用一个用于安抚的技能话题。
  - BEFORE_GOAL: 新话题会放到当前Stage的某一个GOAL之前，配合timing_to指定会谈脚本中哪个话题的名称。如果timing_to没有指定，且代表当前话题。会暂停当前话题，然后执行新话题，再继续执行当前话题。例如，了解完来访者家庭成员有谁，然后调用一个“简单了解关系”的技能来逐一了解每个成员，然后可以回到当前的goal再继续往下。
  - AFTER_GOAL: 新话题会放到当前stage的某一个goal之后执行，配合timing_to指定会谈脚本中哪个话题的名称。如果timing_to没有指定，且代表当前话题，会插入到当前话题之后进行。如果新话题不用很急，可以采用这个方式，比较会不强硬中断对话。
  - AFTER_STAGE: 新话题会放到当前session的某一个stage之后执行，配合timing_to指定会谈脚本中哪个stage的名称。如果timing_to没有指定，则代表当前stage，会插入到当前stage最后执行。
- timing_to: [新话题插入位置]: 配合上面的timing使用，特别用来指定goal或stage的名称
- fromlist: [列表名]: 指定一个列表变量，会对该列表中每一条子对象创建一个话题。例如指定"家庭成员列表"，则会逐一对家庭成员创建一个新话题。如果是一个列表，则output输出的信息，也会存到这个列表中。
如果指定了fromlist，那么input中value的部分往往是fromlist的每一行对象中的字段名。
      建议这fromlist的这个列表定义在stage这一层次，如果是timing=AFTER_STAGE，则在session这层次去declare。以便输出的结果可以被同一个session或同一个stage去访问使用。
- input:
  - set: [调用变量]
    value: "{[技能变量]}"
相当于函数调用的输入参数。set指新话题中的技能变量，往往在goal的declare中定义。value指向当前环境的调用者的变量。但对于·环境的变量，由于是取值，需要外面加"{}"，记得最后面一定要有引号，否则脚本加载会出错。
- output:
  - set: [调用变量]
    value: "{[技能变量]}"
相当于函数调用的返回值。set和value对应的变量作用域正好与input不同。set指当前环境的调用者的变量。value指新话题中的技能变量，往往在goal的declare中定义。由于是取值，需要外面加"{}"，记得最后面一定要有引号，否则脚本加载会出错。
- condition: [执行条件]：（非必要项）条件表达式，返回TRUE时，才会执行本action。具体参见condition介绍。
示例：调用处
- goal: testcalls
  actions:
  - ai_ask: |
      询问家里有哪些主要成员，心旅者对该成员的称呼
    tolist: 家庭主要成员
    output:
    - get: 成员角色
      define: 提取家庭成员相对于来访者的关系角色，转存成父、母、夫、妻、子、女、姐、妹、兄、弟。子女、兄弟、姐妹由于存在若干个可以加上排行。
    - get: 成员称呼
      define: 来访者对该成员一般的称呼
  
  - call: 深度了解关系情况
    timing: BEFORE_GOAL
    fromlist: 家庭主要成员
    input:
    - set: 称呼
      value: "{成员称呼}"
    - set: 角色
      value: "{成员角色}"
    output:
    - set: 成员称呼
      value: "{称呼}"
    - set: 成员关系情况
      value: "{关系情况}"
    
  - say: 家庭主要成员情况："{家庭主要成员}"
示例：技能的定义
skills:
- goal: 深度了解关系情况
  declare:
    - var: 角色
      define: 相对于心旅者的关系角色
    - var: 称呼
      define: 心旅者对他的称呼
    - var: 关系情况
      define: 心旅者该角色的关系情况
  actions:
  - ai_ask: 询问与{角色}{称呼}日常相处的关系情况，只要心旅者讲述了，就不再询问
    output:
    - get: 关系情况
      define: 心旅者该角色的关系情况
output:
守望精灵：你都和谁住在一起，每个人你日常怎么称呼
心旅者：我家有母亲，我叫她“珍姐”， 还有父亲，我叫他“老爹”。
守望精灵：你和父母住在一块
------这里会提取出一个“家庭主要成员”列表，[{角色=父亲, 称呼=老爹}, {角色=母亲, 称呼=珍姐}]
------新话题询问与母亲关系
守望精灵：你与你珍姐的平时关系如何
心旅者：我跟她关系很好，以前外出工作几年，每周都会给她打三次电话
------新话题询问与父亲关系
守望精灵：很好呀，那你与你老爹的关系如何？
心旅者：他平时话少，但我有时也会和他聊一些科学知识
守望精灵：了解，你和父亲还能有共同话题。
------会将关系情况存回“家庭主要成员”列表
守望精灵：家庭主要成员情况：[{角色=父亲, 称呼=老爹, 情况=与老爹有共同话题}, {角色=母亲, 称呼=珍姐, 情况=关系很好，分别时经常联系}]
用途：
- 在会谈脚本中，调用一个技能，如果情绪识别，询问与某个对象的关系
- 在规则脚本中，可以在检测到某个情况时，通过call来执行一个新话题。例如检测到用户有阻抗时，对这个阻抗进行自动思维的挖掘。
4. 脚本引擎能力
4.1 对当前时间感知
问题：由于GPT本身是不知道当前时间的，有时候对话过程，想要了解来访者某个问题发生了多长时间，来访者讲述从某个时间开始，AI如何可以自动知道多长时间了。
系统能力：
在ai_say和ai_ask的智能生成时，都可以感知系统当前的时间，可以到秒。
例如：
当前时间2023/10/31
心谷向导：你失眠多长时间了
来访者：我从今年五一，当时记得要准备五一后的一次谈判
心谷向导：看来你已经失眠有半年了，。。
4.2 自动更新变量（待实现）
问题一：准备要问的信息，用户已经在前面对话中讲过了。一个ai_ask要获取的信息，有可能之前聊天用户已经有讲述过了，因此不要重复询问，或着可以接着之前的信息深入问。但由于ai_ask只带入有限最新对话记录（不超过1000个字，具体根据程序设定），因此在最新对话记录之外的信息，此时ai_ask就会从头问起。
例如：
心谷向导：你遇到了什么困扰
心旅者：我最近很容易烦躁，那天莫名其妙和我最好的朋友阿东吵架了
。。。（超过一定字数）。。。
心谷向导：接下来，我需要了解一些你与朋友的关系
心旅者：没问题
心谷向导：你除了和阿乐吵架，与其他朋友关系如何？
问题二：已经收集的信息，用户在后面更新了。一个ai_ask收集了信息，但后面用户更新了这个信息，这时需要自动把这个信息更新到变量中。
例如：
心谷向导：你有几个兄弟姐妹
心旅者：有一个姐姐
。。。（已经将有一个姐姐get到“家庭成员情况”中）。。。
。。。。（会谈继续进行一段时间）。。。
心旅者：刚说得不准确，我算是有两个姐姐，大的是我母亲养大的，从小也住一块的。
。。。（此时需要更新“家庭成员情况”）。。。。
。。。。（会谈继续进行一段时间）。。。
心谷向导：接下来我想了解一下你与家庭每个人的关系
心谷向导：你与你大姐和二姐关系如何
。。。（此时提示词用到的{家庭成员情况}有包括两个姐姐）。。。
实现办法：
- 在global\session\stage\goal的declare中声明的变量，可以设置“auto=true”（见“如何定义变量”），则系统在一些时间点上，自动去从之前一段聊天记录里，更新这些变量。
- session定义的变量，一旦设置自动更新，则在整个会谈过程中都会收集或更新这个变量。
- 为了防止变量太多，影响更新性能和成本，系统自动会在最后一次用到这个变量之后，就不再更新这个变量。
